%%  diffListConvert(Xs,Ys,Regular)
%% ---------------------------------------
%%    holds if Xs/Ys is a difference list
%%    representation of Regular

%%  Base Case: empty list

diffListConvert(Ys,Ys,[]).

%%  Recursive Case:  non-empty list

diffListConvert([X|Big], Little, [X|Regular])
  :- diffListConvert(Big,Little,Regular).


%%  dl_string_to_number(Big,Little,Numby).
%% -----------------------------------------------------
%%  Holds if the Difference List Big/Little is a String
%%  representation of the Prolog number Numby.

dl_string_to_number(Big,Little,Numby) 
  :- diffListConvert(Big,Little,Listy),
     number_codes(Numby,Listy).


%%  dl_string_to_atom(Big,Little,Adam).
%% -----------------------------------------------------
%%  Holds if the Difference List Big/Little is a String
%%  representation of the Prolog atom Adam.

dl_string_to_atom(Big,Little,Adam)
  :- diffListConvert(Big,Little,Listy),
     atom_codes(Adam,Listy).


%%  isLetter
%% ----------------------------
%%  INPUT:  C, a number
%% ----------------------------
%%  isLetter(C) holds if C is an ASCII code for a letter 
%%  (either from 'a' to 'z', or from 'A' to 'Z').
%%  NOTE:  =< and >= work well on ASCII codes (i.e., numbers).

%%  Case 1:  C is the code for a lower-case letter
isLetter(C) :-  
  char_code(a,Ca),
  char_code(z,Cz),
  C >= Ca,
  C =< Cz.

%%  Case 2:  C is the code for an upper-case letter
isLetter(C) :-
  char_code('A',CA),
  char_code('Z',CZ),
  C >= CA,
  C =< CZ.


%%  isNumeral
%% ----------------------------
%%  INPUT:  C, a number
%% ----------------------------
%%  isLetter(C) holds if C is an ASCII code for a numeral 
%%  (from '0' to '9').

isNumeral(C) :-  
  char_code('0',Cz),
  char_code('9',Cn),
  C >= Cz,
  C =< Cn.

%%---------------------------------------------------------------

%true --> "#t".
%false --> "#f".
%bool --> true.
%bool --> false.
bool(bool(true)) --> "#t".
bool(bool(false)) --> "#f".


%trueParse(true,Xs,Ys) :-
% true(Xs,Ys).
%falseParse(false,Xs,Ys) :-
%  false(Xs,Ys).
%boolParse(bool(Boolean),Xs,Ys) :-
%  false(Xs,Ys),
%  falseParse(Boolean,Xs,Ys).
%boolParse(bool(Boolean),Xs,Ys) :-
%  true(Xs,Ys),
%  trueParse(Boolean,Xs,Ys).

%null --> "()".
%nullParse(null,Xs,Ys) :-
%  null(Xs,Ys).

null(null) --> "()".

aNum --> [N], {isNumeral(N)}.
nums --> aNum.
nums --> aNum, nums.

num(num(Atnum),Xs,Ys) :-
  nums(Xs,Ys),
  dl_string_to_number(Xs,Ys,Atnum).



anId --> [L], {isLetter(L)}.
ids --> anId.
ids --> anId, ids.

id(id(Atid),Xs,Ys) :-
  ids(Xs,Ys),
  dl_string_to_atom(Xs,Ys,Atid).

allParse(P, Xs, Ys) :-
  bool(Xs,Ys),
  boolParse(P,Xs,Ys).

allParse(P, Xs, Ys) :-
  null(Xs,Ys),
  nullParse(P,Xs,Ys).

allParse(P, Xs, Ys) :-
  id(Xs,Ys),
  idParse(P,Xs,Ys).
  
allParse(P, Xs, Ys) :-
  num(Xs,Ys),
  numParse(P,Xs,Ys).

scheme(Tree) --> bool(Tree).
scheme(Tree) --> num(Tree).
scheme(Tree) --> id(Tree).
scheme(Tree) --> null(Tree).

ws --> " ".
ws --> " ", ws.
wsopt --> "".
wsopt --> ws.

listItem(Tree) --> wsopt, scheme(Tree), ws.
listItem(cons(Tree, null)) --> wsopt, scheme(Tree), wsopt, ")".

list(Tree) --> listItem(Tree).
list(cons(Tree,RTree)) --> listItem(Tree), list(RTree).

expr(Tree) --> scheme(Tree).
expr(Tree) --> "(", list(Tree).


listSingle --> "(", scheme, ")".


listContents(Contents,Xs,Ys) :-
  diffListConvert(Xs,Ys,[40|Rest]),
  diffListConvert(Rest,")",Contents).

multContents(cons(STree,MTree)) -->
  allParse(STree,scheme,""), ws, multContents(MTree). 



listSingleParse(cons(Item,null), Xs, Ys) :-
  listSingle(Xs,Ys),
  listContents(Contents,Xs,Ys),
  allParse(Item,Contents,"").  





